# 區塊鏈期末專案 - 實驗記錄 

本記錄記載從在 Cosmos SDK 上，從環境準備到實現自訂模組功能的區塊鏈開發過程。

* 實驗環境: Ubuntu 22.04

## 第 0 步：環境準備 (Prerequisites)

1.  **安裝與設定開發工具**
    * 安裝 `vscode` 編輯器：
        ```bash
        sudo snap install code --classic
        ```
    * 驗證 `vscode` 的安裝：
        ```bash
        code --version
        ```
    * 若 `code --version` 命令失敗，會執行以下命令將 `/snap/bin` 加入 PATH：
        ```bash
        export PATH="$PATH:/snap/bin"
        ```
 

2.  **安裝 Go 語言 (Golang)**:
    * 下載並安裝 Go 1.23.0：
        ```bash
        wget https://go.dev/dl/go1.23.0.linux-amd64.tar.gz
        sudo rm -rf /usr/local/go && sudo tar -C /usr/local -xzf go1.23.0.linux-amd64.tar.gz
        ```
    * 設定 Go 環境變數，將以下內容加入到 `~/.bashrc` 檔案中：
        ```bash
        echo 'export GOPATH=$HOME/go' >> ~/.bashrc
        echo 'export GOROOT=/usr/local/go' >> ~/.bashrc
        echo 'export PATH=$PATH:$GOPATH/bin:$GOROOT/bin' >> ~/.bashrc
        echo 'export GO111MODULE=on' >> ~/.bashrc
        ```
    * 然後重新載入 shell 設定：
        ```bash
        source ~/.bashrc
        ```
    * 驗證 Go 的安裝：
        ```bash
        go version
        ```
        輸出確認為 Go 1.23.0。

3.  **安裝 Git**:
    * 確認系統中已安裝 Git。若未安裝，會使用以下命令安裝 (以 Ubuntu 為例)：
        ```bash
        sudo apt install git
        ```

4.  **安裝必要的建構工具**:
    * 更新包列表並安裝 `build-essential`, `curl`, `wget`, 和 `jq`：
        ```bash
        # Ubuntu/Debian
        sudo apt update
        sudo apt install build-essential curl wget jq
        ```

## 第 1 步：安裝 Ignite CLI

安裝 Ignite CLI 以簡化 Cosmos SDK 區塊鏈的開發。

1.  **安裝 Ignite CLI**:
    * 安裝 Ignite CLI v0.27.2(新版遇到問題)：
        ```bash
        curl https://get.ignite.com/cli@v0.27.2! | bash
        ```
    * 驗證 Ignite CLI 的安裝：
        ```bash
        ignite version
        ```
        輸出確認為 Ignite CLI v0.27.2。

## 第 2 步：創建投票區塊鏈專案

創建一個名為 `votesystem` 的區塊鏈專案。

1.  **使用 Ignite CLI 創建新的區塊鏈專案**:
    * 執行以下命令
        ```bash
        ignite scaffold chain votesystem --address-prefix vote1
        ```
        `--address-prefix vote1` 設定鏈上地址的前綴。
    * 進入專案目錄：
        ```bash
        cd votesystem
        ```

## 第 3 步：添加自訂模組框架

為投票系統創建 `identity`、`votecoin` 和 `voting` 三個核心模組的框架。

### A. 添加 `identity` 模組

* **目的**: 管理選民的鏈上身份驗證狀態。

1.  **創建模組框架**:
    ```bash
    ignite scaffold module identity --dep bank
    ```
2.  **定義資料結構 (Types)**:
    * 為儲存已註冊選民的資訊創建一個列表：
    ```bash
    ignite scaffold list registeredVoter voterAddress:string identityProofHash:string --module identity --no-message
    ```
3.  **定義訊息 (Msgs - 交易類型)**:
    * 為選民註冊創建一個訊息：
    ```bash
    ignite scaffold message registerVoter identityProofHash:string --signer voter --module identity
    ```
4.  **定義查詢 (Queries)**:
    * 為查詢某個地址是否已註冊創建一個查詢：
    ```bash
    ignite scaffold query getVoterStatus voterAddress:string --module identity
    ```

### B. 添加 `votecoin` 模組

* **目的**: 實現和管理不可轉讓的 "VoteCoin"。

1.  **創建模組框架**:
    ```bash
    ignite scaffold module votecoin --dep bank
    ```
2.  **定義訊息 (Msgs)**:
    * 為管理員向已驗證選民發放 VoteCoin 創建一個訊息：
    ```bash
    ignite scaffold message issueVoteCoin recipient:string amount:int --signer admin --module votecoin
    ```

### C. 添加 `voting` 模組

* **目的**: 處理實際的投票過程。

1.  **創建模組框架**:
    ```bash
    ignite scaffold module voting --dep bank,identity,votecoin
    ```
2.  **定義資料結構 (Types)**:
    * 為儲存選票資訊創建一個列表：
    ```bash
    ignite scaffold list voteRecord voterAddress:string candidateID:string electionID:string --module voting --no-message
    ```
    * 為標記某個選民是否已在特定選舉中投過票創建一個 map：
    ```bash
    ignite scaffold map HasVotedVoter electionID:string voterAddress:string votedStatus:bool --module voting --no-message
    ```
3.  **定義訊息 (Msgs - 交易類型)**:
    * 為核心的投票功能創建一個訊息：
    ```bash
    ignite scaffold message castVote candidateID:string electionID:string --signer voter --module voting
    ```
4.  **定義查詢 (Queries)**:
    * 為查詢投票結果創建一個查詢：
    ```bash
    ignite scaffold query getElectionResult electionID:string --module voting
    ```

## 第 4 步：編譯區塊鏈應用

在添加完模組框架後，編譯應用程式。

1.  **整理 Go 模組依賴**:
    ```bash
    go mod tidy
    ```
2.  **建構 (編譯) 應用程式**:
    ```bash
    ignite chain build
    ```
    編譯成功，生成 `votesystemd` 二進制檔案。

## 第 5 步：初始化並運行單節點測試網路

初始化並運行一個單節點網路進行初步測試。

1.  **清除舊的測試網路數據 (如果有的話)**:
    ```bash
    rm -rf ~/.votesystem/
    ```
    (在此次實驗中，使用 `~/.votesystem/` 作為配置目錄，因此對應命令為 `rm -rf ~/.votesystem/`)
2.  **初始化鏈配置**:
    * 使用 `mynode` 作為節點名稱：
        ```bash
        votesystemd init mynode --chain-id voting-chain-dev
        ```
3.  **創建測試帳戶**:
    ```bash
    votesystemd keys add alice --keyring-backend test
    votesystemd keys add bob --keyring-backend test
    ```
    記錄下 `alice` 和 `bob` 帳戶的地址和助記詞。
4.  **將帳戶添加到創世文件 (Genesis File) 並分配初始代幣**:
    * 為 `alice` 和 `bob` 分配 `stake` 和 `votecredit` (示例代幣)：
        ```bash
        ALICE_ADDR=$(votesystemd keys show alice -a --keyring-backend test)
        BOB_ADDR=$(votesystemd keys show bob -a --keyring-backend test)
        votesystemd add-genesis-account $ALICE_ADDR 1000000000stake,1000000votecredit
        votesystemd add-genesis-account $BOB_ADDR 500000000stake,500000votecredit
        ```
5.  **為驗證者生成創世交易 (Gentx)**:
    * 將 `alice` 設為初始驗證者：
        ```bash
        votesystemd gentx alice 1000000stake --chain-id voting-chain-dev --from $ALICE_ADDR --keyring-backend test
        ```
6.  **收集創世交易**:
    ```bash
    votesystemd collect-gentxs
    ```
7.  **驗證創世文件**:
    ```bash
    votesystemd validate-genesis
    ```
    驗證通過。
8.  **啟動單節點網路**:
    ```bash
    votesystemd start
    ```
    節點成功啟動並開始產生區塊。

## 第 6 步：實現模組邏輯

這一步是專案的核心，為 `identity`、`votecoin` 和 `voting` 三個模組編寫實際的業務邏輯。
確認鏈二進制檔案名是 `votesystemd`，配置資料夾是 `~/.votesystemd/`。

---

### 第 6.1 步：實現 `identity` 模組邏輯

#### A. 實現 `RegisterVoter` 訊息處理邏輯

1.  **修改檔案** `x/identity/keeper/msg_server_register_voter.go`:
    ```go
    package keeper

    import (
        "context"
        "fmt"

        "votesystem/x/identity/types" // 確認路徑正確
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
    )

    func (k msgServer) RegisterVoter(goCtx context.Context, msg *types.MsgRegisterVoter) (*types.MsgRegisterVoterResponse, error) {
        ctx := sdk.UnwrapSDKContext(goCtx)

        // 1. 驗證 identityProofHash 是否為空
        if msg.IdentityProofHash == "" {
            return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "identity proof hash cannot be empty")
        }

        // 2. 獲取簽名者地址 (即選民地址)
        voterAddress, err := sdk.AccAddressFromBech32(msg.Voter)
        if err != nil {
            return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidAddress, "invalid voter address")
        }
        // 添加日誌：記錄嘗試註冊的選民地址和雜湊
        k.Logger(ctx).Info("Attempting to register voter", "address", voterAddress.String(), "hash", msg.IdentityProofHash)

        // 3. 檢查選民是否已註冊
        allRegisteredVoters := k.GetAllRegisteredVoter(ctx)
        // 添加日誌：記錄 GetAllRegisteredVoter 返回的結果
        k.Logger(ctx).Info("Retrieved voters for check", "count", len(allRegisteredVoters))
        if len(allRegisteredVoters) > 0 {
            // 如果列表不為空，記錄列表中第一個選民的詳細資訊以供檢查
            k.Logger(ctx).Info("First voter in list", "address", allRegisteredVoters[0].VoterAddress, "hash", allRegisteredVoters[0].IdentityProofHash)
        }


        for i, registeredVoter := range allRegisteredVoters {
            // 添加日誌：記錄正在檢查的每個選民以及比較結果
            k.Logger(ctx).Info("Checking voter from store",
                "index", i,
                "storedVoterAddress", registeredVoter.VoterAddress,
                "msgVoterAddress", voterAddress.String(),
                "isMatch", registeredVoter.VoterAddress == voterAddress.String())

            if registeredVoter.VoterAddress == voterAddress.String() {
                // 添加日誌：記錄發現選民已註冊
                k.Logger(ctx).Info("Voter already registered", "address", voterAddress.String())
                return nil, sdkerrors.Wrap(types.ErrVoterAlreadyRegistered, fmt.Sprintf("voter %s already registered", voterAddress.String()))
            }
        }

        // 4. 創建新的 RegisteredVoter 對象
        newVoter := types.RegisteredVoter{
            VoterAddress:      voterAddress.String(),
            IdentityProofHash: msg.IdentityProofHash,
        }

        // 5. 將新選民添加到儲存中
        k.AppendRegisteredVoter(ctx, newVoter)
        // 添加日誌：記錄已添加的新選民
        k.Logger(ctx).Info("Appended new voter", "address", newVoter.VoterAddress, "hash", newVoter.IdentityProofHash)

        // ... 函數的其餘部分
        err = ctx.EventManager().EmitTypedEvent(&types.EventVoterRegistered{
            VoterAddress:      voterAddress.String(),
            IdentityProofHash: msg.IdentityProofHash,
        })
        if err != nil {
            k.Logger(ctx).Error("failed to emit EventVoterRegistered", "error", err)
        }

        return &types.MsgRegisterVoterResponse{}, nil
    }
    ```
2.  **定義錯誤類型**: 打開 `x/identity/types/errors.go` 並添加 `ErrVoterAlreadyRegistered` 和 `ErrVoterNotRegistered`：
    ```go
    package types

    import (
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
    )

    // x/identity module sentinel errors
    var (
        ErrVoterAlreadyRegistered = sdkerrors.Register(ModuleName, 1100, "voter already registered")
        ErrVoterNotRegistered     = sdkerrors.Register(ModuleName, 1101, "voter not registered") // 為之後投票模組準備
        // 您可以根據需要添加更多錯誤
    )
    ```
3.  **定義事件**: 
    創建 `x/identity/types/events.go` ：
    ```go
    package types

    // Event types for the identity module
    const (
        EventTypeVoterRegistered = "voter_registered"
        // Attribute keys
        AttributeKeyVoterAddress      = "voter_address"
        AttributeKeyIdentityProofHash = "identity_proof_hash"
    )
    ```
    然後，在 `proto/votesystem/identity/tx.proto` 添加事件定義：
    ```protobuf
    // EventVoterRegistered is emitted on Msg/RegisterVoter success
    message EventVoterRegistered {
      string voter_address = 1;
      string identity_proof_hash = 2;
    }
    ```
    之後，重新生成 protobuf 程式碼：
    ```bash
    ignite generate proto-go
    ```
4.  **驗證與測試 `RegisterVoter`**:
    * 重新編譯鏈：
        ```bash
        ignite chain build
        ```
    * 清除舊數據並重新初始化和啟動鏈：
        ```bash
        rm -rf ~/.votesystem/
        votesystemd init mynode --chain-id voting-chain-dev
        votesystemd keys add alice --keyring-backend test
        votesystemd keys add bob --keyring-backend test
        ALICE_ADDR=$(votesystemd keys show alice -a --keyring-backend test)
        BOB_ADDR=$(votesystemd keys show bob -a --keyring-backend test)
        votesystemd add-genesis-account $ALICE_ADDR 1000000000stake
        votesystemd add-genesis-account $BOB_ADDR 500000000stake
        votesystemd gentx alice 1000000stake --chain-id voting-chain-dev --from $ALICE_ADDR --keyring-backend test
        votesystemd collect-gentxs
        votesystemd validate-genesis
        votesystemd start
        ```
        (保持此終端運行)
    * 在另一個終端中，使用 `alice` 帳戶註冊一個選民：
        ```bash
        ALICE_ADDR=$(votesystemd keys show alice -a --keyring-backend test)
        votesystemd tx identity register-voter "my_unique_identity_hash_123" --from $ALICE_ADDR --chain-id voting-chain-dev --fees 5stake --keyring-backend test -y
        ```
        交易成功。記錄交易雜湊值。
    * 檢查交易結果 (將 `<YOUR_TX_HASH>` 替換為實際的交易雜湊值)：
        ```bash
        votesystemd query tx <YOUR_TX_HASH>
        ```
        輸出顯示 `code: 0`。
    * 嘗試再次註冊同一個選民 `alice`：
        ```bash
        votesystemd tx identity register-voter "another_hash_for_alice" --from $ALICE_ADDR --chain-id voting-chain-dev --fees 5stake --keyring-backend test -y
        ```
        這次交易失敗，並提示 "voter already registered"，符合預期。

#### B. 實現 `GetVoterStatus` 查詢邏輯

1.  **修改檔案** `x/identity/keeper/query_get_voter_status.go`:
    
    ```go
    package keeper

    import (
        "context"

        "votesystem/x/identity/types" // 確認路徑正確
        sdk "github.com/cosmos/cosmos-sdk/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
    )

    func (k Keeper) GetVoterStatus(goCtx context.Context, req *types.QueryGetVoterStatusRequest) (*types.QueryGetVoterStatusResponse, error) {
        if req == nil {
            return nil, status.Error(codes.InvalidArgument, "invalid request")
        }

        ctx := sdk.UnwrapSDKContext(goCtx)

        _, err := sdk.AccAddressFromBech32(req.VoterAddress)
        if err != nil {
            return nil, status.Error(codes.InvalidArgument, "invalid voter address format")
        }

        allRegisteredVoters := k.GetAllRegisteredVoter(ctx)
        for _, registeredVoter := range allRegisteredVoters {
            if registeredVoter.VoterAddress == req.VoterAddress {
                // 找到選民，返回其資訊
                return &types.QueryGetVoterStatusResponse{
                    IsRegistered:      true,
                    IdentityProofHash: registeredVoter.IdentityProofHash,
                }, nil
            }
        }

        // 未找到選民
        return &types.QueryGetVoterStatusResponse{
            IsRegistered:      false,
            IdentityProofHash: "",
        }, nil
    }
    ```
2.  **定義查詢回應**: 在 `proto/votesystem/identity/query.proto` 中定義 `QueryGetVoterStatusResponse`：
    ```protobuf
    message QueryGetVoterStatusResponse {
      bool is_registered = 1;
      string identity_proof_hash = 2;
    }
    ```
    然後運行 
    ```
    ignite generate proto-go
    ```
3.  **驗證與測試 `GetVoterStatus`**:
    * 重新編譯鏈：
        ```bash
        ignite chain build
        ```
    * 重啟鏈 
        ```bash
        votesystemd start
        ```
    * 在另一個終端中，執行查詢：
        * 查詢 `alice` 的註冊狀態：
            ```bash
            ALICE_ADDR=$(votesystemd keys show alice -a --keyring-backend test)
            votesystemd query identity get-voter-status $ALICE_ADDR
            ```
            輸出為：
            ```json
            {
              "is_registered": true,
              "identity_proof_hash": "my_unique_identity_hash_123"
            }
            ```
        * 查詢 `bob` 的註冊狀態：
            ```bash
            BOB_ADDR=$(votesystemd keys show bob -a --keyring-backend test)
            votesystemd query identity get-voter-status $BOB_ADDR
            ```
            輸出為：
            ```json
            {
              "is_registered": false,
              "identity_proof_hash": ""
            }
            ```
        結果符合預期。


---

### 第 6.2 步：實現 `votecoin` 模組邏輯

#### A. 定義 VoteCoin 並在 Genesis 中初始化

1.  **修改 `x/votecoin/genesis.go`**:
    在 `InitGenesis` 函數中設定代幣的元數據，並定義相關常量：
    ```go
    package votecoin

    import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        banktypes "github.com/cosmos/cosmos-sdk/x/bank/types" // 新增 banktypes 導入
        "votesystem/x/votecoin/keeper"
        "votesystem/x/votecoin/types"
    )

    // 常量
    const (
        VoteCoinDenom    = "votecredit" 
        VoteCoinDisplay  = "VoteCredit"
        VoteCoinExponent = 0 // 如果 votecredit 是最小單位，則為 0
    )

    // InitGenesis initializes the module's state from a provided genesis state.
    func InitGenesis(ctx sdk.Context, k keeper.Keeper, genState types.GenesisState) {
        // this line is used by starport scaffolding # genesis/module/init
        k.SetParams(ctx, genState.Params) 

        // 設置 votecredit 代幣的元數據
        metadata, found := k.BankKeeper.GetDenomMetaData(ctx, VoteCoinDenom)
        if !found {
            k.BankKeeper.SetDenomMetaData(ctx, banktypes.Metadata{
                Description: "A non-transferable token for voting purposes.",
                DenomUnits: []*banktypes.DenomUnit{
                    {Denom: VoteCoinDenom, Exponent: uint32(VoteCoinExponent), Aliases: []string{"voting credit"}},
                },
                Base:    VoteCoinDenom,
                Display: VoteCoinDisplay,
                Name:    VoteCoinDisplay,
                Symbol:  "VCRD", // 自訂一個代幣符號
            })
        } else {
            ctx.Logger().Info("VoteCoin metadata already exists", "denom", VoteCoinDenom, "description", metadata.Description)
        }
    }

    // ExportGenesis returns the module's exported genesis
    func ExportGenesis(ctx sdk.Context, k keeper.Keeper) *types.GenesisState {
        genesis := types.DefaultGenesis()

        genesis.Params = k.GetParams(ctx)

        // this line is used by starport scaffolding # genesis/module/export

        return genesis
    }

    ```
    
2.  **修改 `x/votecoin/keeper/keeper.go`**:
    將 `bankKeeper` 欄位名修改為 `BankKeeper`（首字母大寫）：
    ```go
    package keeper

    import (
        "fmt"

        "github.com/cometbft/cometbft/libs/log"
        "github.com/cosmos/cosmos-sdk/codec"
        storetypes "github.com/cosmos/cosmos-sdk/store/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        paramtypes "github.com/cosmos/cosmos-sdk/x/params/types"

        "votesystem/x/votecoin/types"
    )

    type (
        Keeper struct {
            cdc        codec.BinaryCodec
            storeKey   storetypes.StoreKey
            memKey     storetypes.StoreKey
            paramstore paramtypes.Subspace

            BankKeeper types.BankKeeper // 修改：首字母 "B" 大寫
        }
    )

    func NewKeeper(
        cdc codec.BinaryCodec,
        storeKey,
        memKey storetypes.StoreKey,
        ps paramtypes.Subspace,

        bankKeeper types.BankKeeper, // 參數名也保持一致
    ) *Keeper {
        // set KeyTable if it has not already been set
        if !ps.HasKeyTable() {
            ps = ps.WithKeyTable(types.ParamKeyTable())
        }

        return &Keeper{
            cdc:        cdc,
            storeKey:   storeKey,
            memKey:     memKey,
            paramstore: ps,

            BankKeeper: bankKeeper, // 修改：首字母 "B" 大寫
        }
    }

    func (k Keeper) Logger(ctx sdk.Context) log.Logger {
        return ctx.Logger().With("module", fmt.Sprintf("x/%s", types.ModuleName))
    }
    ```
3.  **修改 `x/votecoin/types/expected_keepers.go`**:
    更新 `BankKeeper` 接口，添加必要的方法：
    ```go
    package types

    import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
        banktypes "github.com/cosmos/cosmos-sdk/x/bank/types" // 新增 banktypes 導入
    )

    // AccountKeeper defines the expected account keeper used for simulations (noalias)
    type AccountKeeper interface {
        GetAccount(ctx sdk.Context, addr sdk.AccAddress) authtypes.AccountI
        // Methods imported from account should be defined here
    }

    // BankKeeper defines the expected interface needed to retrieve account balances.
    type BankKeeper interface {
        // --- 原有的方法 ---
        SpendableCoins(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins

        // --- 為 genesis.go 添加的方法 ---
        GetDenomMetaData(ctx sdk.Context, denom string) (banktypes.Metadata, bool)
        SetDenomMetaData(ctx sdk.Context, denomMetaData banktypes.Metadata)

        // --- 為 msg_server_issue_vote_coin.go (第 6.2.B 步) 添加的方法 ---
        MintCoins(ctx sdk.Context, moduleName string, amt sdk.Coins) error
        SendCoinsFromModuleToAccount(ctx sdk.Context, senderModule string, recipientAddress sdk.AccAddress, amt sdk.Coins) error
        BurnCoins(ctx sdk.Context, moduleName string, amt sdk.Coins) error // 用於 IssueVoteCoin 失敗時的回滾
    }
    ```
4.  **驗證與測試 Genesis 初始化**:
    * 重新編譯鏈：`ignite chain build`
    * 清除舊數據並重新初始化和啟動鏈，這次在 `add-genesis-account` 中加入 `votecredit`：
        ```bash
        rm -rf ~/.votesystem/ 
        votesystemd init mynode --chain-id voting-chain-dev
        votesystemd keys add alice --keyring-backend test
        votesystemd keys add bob --keyring-backend test
        ALICE_ADDR=$(votesystemd keys show alice -a --keyring-backend test)
        BOB_ADDR=$(votesystemd keys show bob -a --keyring-backend test)
        votesystemd add-genesis-account $ALICE_ADDR 1000000000stake,1000000votecredit
        votesystemd add-genesis-account $BOB_ADDR 500000000stake
        votesystemd gentx alice 1000000stake --chain-id voting-chain-dev --from $ALICE_ADDR --keyring-backend test
        votesystemd collect-gentxs
        votesystemd validate-genesis
        votesystemd start
        ```
    * 在另一個終端中，查詢代幣元數據：
        ```bash
        votesystemd query bank denom-metadata votecredit
        ```
        成功看到 `votecredit` 的元數據。
    * 查詢 `alice` 的餘額：
        ```bash
        ALICE_ADDR=$(votesystemd keys show alice -a --keyring-backend test)
        votesystemd query bank balances $ALICE_ADDR
        ```
        確認 `alice` 擁有 `1000000votecredit`。

#### B. 實現 `IssueVoteCoin` 訊息處理邏輯

1.  **修改 `x/votecoin/keeper/msg_server_issue_vote_coin.go`**:
    更新 `IssueVoteCoin` 函數的邏輯：
    ```go
    package keeper

    import (
        "context"
        "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
        "votesystem/x/votecoin/types" // 確保這裡的路徑是正確的
    )

    // IssueVoteCoin 處理管理員向特定接收者發放 VoteCoin 的邏輯
    func (k msgServer) IssueVoteCoin(goCtx context.Context, msg *types.MsgIssueVoteCoin) (*types.MsgIssueVoteCoinResponse, error) {
        ctx := sdk.UnwrapSDKContext(goCtx)

        // 1. 獲取簽名者 (管理員) 地址
        adminAddress, err := sdk.AccAddressFromBech32(msg.Admin)
        if err != nil {
            return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidAddress, "invalid admin address")
        }

        // 2. 驗證簽名者是否是管理員 (簡化版，實際項目中需加強)
        k.Logger(ctx).Info(fmt.Sprintf("IssueVoteCoin called by: %s. In a real app, verify this is an admin!", msg.Admin))

        // 3. 獲取接收者地址
        recipientAddress, err := sdk.AccAddressFromBech32(msg.Recipient)
        if err != nil {
            return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidAddress, "invalid recipient address")
        }

        // 4. 驗證數量
        if msg.Amount <= 0 {
            return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "amount must be positive")
        }
        amount := sdk.NewInt(int64(msg.Amount)) // msg.Amount 是 int32，轉換為 int64
        coinsToIssue := sdk.NewCoins(sdk.NewCoin(types.VoteCoinDenom, amount))

        // 5. 鑄造代幣到 votecoin 模組帳戶
        err = k.BankKeeper.MintCoins(ctx, types.ModuleName, coinsToIssue)
        if err != nil {
            return nil, sdkerrors.Wrap(err, "failed to mint coins")
        }

        // 6. 從模組帳戶發送代幣給接收者
        err = k.BankKeeper.SendCoinsFromModuleToAccount(ctx, types.ModuleName, recipientAddress, coinsToIssue)
        if err != nil {
            burnErr := k.BankKeeper.BurnCoins(ctx, types.ModuleName, coinsToIssue)
            if burnErr != nil {
                k.Logger(ctx).Error(fmt.Sprintf("CRITICAL: failed to burn coins after send failed: %v. Module account may have unallocated tokens.", burnErr))
            }
            return nil, sdkerrors.Wrap(err, "failed to send coins to recipient")
        }

        // 7. (可選) 發出事件
        err = ctx.EventManager().EmitTypedEvent(&types.EventVoteCoinIssued{
            Admin:     adminAddress.String(),
            Recipient: recipientAddress.String(),
            Amount:    amount.String(),
        })
        if err != nil {
            k.Logger(ctx).Error("failed to emit EventVoteCoinIssued", "error", err)
        }

        return &types.MsgIssueVoteCoinResponse{}, nil
    }
    ```
2.  **定義事件**: 
    創建 `x/votecoin/types/events.go`：
    ```go
    package types

    const (
        EventTypeVoteCoinIssued = "votecoin_issued"
        AttributeKeyAdmin       = "admin"
        AttributeKeyRecipient   = "recipient"
        AttributeKeyAmount      = "amount"
    )
    ```
    然後，在 `proto/votesystem/votecoin/tx.proto` 添加事件定義
    ```protobuf
    message EventVoteCoinIssued {
      string admin = 1;
      string recipient = 2;
      string amount = 3;
    }
    ```
    之後，重新生成 protobuf 程式碼：
    ```
    ignite generate proto-go
    ```
3.  **修改 `x/votecoin/types/key.go`**:
    添加 `VoteCoinDenom` 常量：
    ```go
    package types

    const (
        ModuleName = "votecoin"
        StoreKey   = ModuleName
        RouterKey  = ModuleName
        MemStoreKey = "mem_votecoin"
        VoteCoinDenom = "votecredit" // 添加此行
    )

    func KeyPrefix(p string) []byte {
        return []byte(p)
    }
    ```
4.  **驗證與測試 `IssueVoteCoin`**:
    * 重新編譯鏈：
        ```
        ignite chain build
        ```
    * 重啟鏈：
        ```
        votesystemd start
        ```
    * 在另一個終端中，讓 `alice` (假設為管理員) 給 `bob` 發放 100 `votecredit`：
        ```bash
        ALICE_ADDR=$(votesystemd keys show alice -a --keyring-backend test)
        BOB_ADDR=$(votesystemd keys show bob -a --keyring-backend test)
        votesystemd tx votecoin issue-vote-coin $BOB_ADDR 100 --from $ALICE_ADDR --chain-id voting-chain-dev --fees 5stake --keyring-backend test -y
        ```
        交易成功。
    * 查詢 `bob` 的 `votecredit` 餘額：
        ```bash
        votesystemd query bank balances $BOB_ADDR
        ```
        確認 `bob` 現在擁有 100 `votecredit` (加上初始分配的，如果有的話)。

---

### 第 6.3 步：實現 `voting` 模組邏輯

#### A. 實現 `CastVote` 訊息處理邏輯

1.  **在 `identity` 模組的 Keeper 中添加輔助函數**:
    打開 `x/identity/keeper/keeper.go` 並添加 `IsVoterRegistered` 函數：
    ```go
    // IsVoterRegistered checks if a voter is registered.
    func (k Keeper) IsVoterRegistered(ctx sdk.Context, voterAddr sdk.AccAddress) bool {
        allRegisteredVoters := k.GetAllRegisteredVoter(ctx)
        for _, registeredVoter := range allRegisteredVoters {
            if registeredVoter.VoterAddress == voterAddr.String() {
                return true
            }
        }
        return false
    }
    ```
2.  **修改 `x/voting/keeper/msg_server_cast_vote.go`**:
    更新 `CastVote` 函數的邏輯：
    ```go
    package keeper

    import (
        "context"
        "fmt"

        identitytypes "votesystem/x/identity/types"    // 導入 identity types 包
        votecointypes "votesystem/x/votecoin/types" // 為了 ModuleName 和 VoteCoinDenom
        "votesystem/x/voting/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
    )

    const VoteCost = 1 // 每票消耗 1 votecredit

    // Helper function to create the composite index
    func createCompositeHasVotedIndex(electionID string, voterAddress string) string {
        return electionID + "/" + voterAddress // 您可以選擇不同的分隔符
    }

    func (k msgServer) CastVote(goCtx context.Context, msg *types.MsgCastVote) (*types.MsgCastVoteResponse, error) {
        ctx := sdk.UnwrapSDKContext(goCtx)

        voterAddress, err := sdk.AccAddressFromBech32(msg.Voter)
        if err != nil {
            return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidAddress, "invalid voter address")
        }

        if msg.ElectionID == "" {
            return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "election ID cannot be empty")
        }
        if msg.CandidateID == "" {
            return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "candidate ID cannot be empty")
        }

        // 3. 使用 identityKeeper 檢查選民是否已註冊
        if !k.identityKeeper.IsVoterRegistered(ctx, voterAddress) {
            return nil, sdkerrors.Wrap(identitytypes.ErrVoterNotRegistered, fmt.Sprintf("voter %s is not registered", voterAddress.String()))
        }

        // 4. 使用 bankKeeper 檢查選民是否有足夠的 VoteCoin
        voteCoinDenom := votecointypes.VoteCoinDenom
        balance := k.bankKeeper.GetBalance(ctx, voterAddress, voteCoinDenom)
        cost := sdk.NewInt(VoteCost)
        if balance.Amount.LT(cost) {
            return nil, sdkerrors.Wrap(types.ErrInsufficientVoteCoin, fmt.Sprintf("insufficient %s to vote. Required: %s, Have: %s", voteCoinDenom, cost.String(), balance.Amount.String()))
        }

        // 5. 構造複合索引並檢查選民是否已在該選舉中投過票
        compositeIndex := createCompositeHasVotedIndex(msg.ElectionID, voterAddress.String())
        hasVotedEntry, found := k.GetHasVotedVoter(ctx, compositeIndex)
        if found && hasVotedEntry.VotedStatus {
            return nil, sdkerrors.Wrap(types.ErrAlreadyVoted, fmt.Sprintf("voter %s has already voted in election %s", voterAddress.String(), msg.ElectionID))
        }

        // 6. 銷毀或鎖定已使用的 VoteCoin
        coinsToBurn := sdk.NewCoins(sdk.NewCoin(voteCoinDenom, cost))
        err = k.bankKeeper.SendCoinsFromAccountToModule(ctx, voterAddress, types.ModuleName, coinsToBurn)
        if err != nil {
            return nil, sdkerrors.Wrap(err, "failed to send coins from voter to module for burning")
        }
        err = k.bankKeeper.BurnCoins(ctx, types.ModuleName, coinsToBurn)
        if err != nil {
            k.Logger(ctx).Error(fmt.Sprintf("critical: failed to burn coins from module account: %v", err))
            // 決定是否返回錯誤
        }

        // 7. 記錄選票到 voteRecord 列表
        voteRecord := types.VoteRecord{
            VoterAddress: voterAddress.String(),
            CandidateID:  msg.CandidateID,
            ElectionID:   msg.ElectionID,
        }
        k.AppendVoteRecord(ctx, voteRecord)

        // 8. 更新 HasVotedVoter map
        newHasVotedEntry := types.HasVotedVoter{
            Index:        compositeIndex,
            ElectionID:   msg.ElectionID,
            VoterAddress: voterAddress.String(),
            VotedStatus:  true,
        }
        k.SetHasVotedVoter(ctx, newHasVotedEntry)

        // 9. (可選) Emit event
        err = ctx.EventManager().EmitTypedEvent(&types.EventVoteCast{
            VoterAddress: voterAddress.String(),
            ElectionId:   msg.ElectionID, // Proto field name is election_id
            CandidateId:  msg.CandidateID, // Proto field name is candidate_id
        })
        if err != nil {
            k.Logger(ctx).Error("failed to emit EventVoteCast", "error", err)
        }

        return &types.MsgCastVoteResponse{}, nil
    }
    ```
3.  **Keeper 依賴**:
    更新 `x/voting/types/expected_keepers.go`：
    ```go
    package types

    import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
    )

    type IdentityKeeper interface {
        IsVoterRegistered(ctx sdk.Context, voterAddr sdk.AccAddress) bool
    }

    type VotecoinKeeper interface {
        // Methods imported from votecoin should be defined here
    }

    type AccountKeeper interface {
        GetAccount(ctx sdk.Context, addr sdk.AccAddress) authtypes.AccountI
    }

    type BankKeeper interface {
        SpendableCoins(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins
        GetBalance(ctx sdk.Context, addr sdk.AccAddress, denom string) sdk.Coin
        SendCoinsFromAccountToModule(ctx sdk.Context, senderAddress sdk.AccAddress, recipientModule string, amt sdk.Coins) error
        BurnCoins(ctx sdk.Context, moduleName string, amt sdk.Coins) error

        // SendCoinsFromModuleToAccount(ctx sdk.Context, senderModule string, recipientAddress sdk.AccAddress, amt sdk.Coins) error
        // MintCoins(ctx sdk.Context, moduleName string, amt sdk.Coins) error
    }
    ```

4.  **錯誤類型**: 在 `x/voting/types/errors.go` 中添加錯誤定義：
    ```go
    package types

    import sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"

    var (
        ErrInsufficientVoteCoin = sdkerrors.Register(ModuleName, 1200, "insufficient vote coin")
        ErrAlreadyVoted         = sdkerrors.Register(ModuleName, 1201, "voter has already voted in this election")
    )
    ```
5.  **定義事件**: 
    修改 `x/voting/types/events.go`：
    ```go
    package types

    const (
        EventTypeVoteCast       = "vote_cast"
        AttributeKeyElectionID  = "election_id"
        AttributeKeyCandidateID = "candidate_id"
        // AttributeKeyVoterAddress can be reused from identitytypes if imported or redefined here
    )
    ```
    並在 `proto/votesystem/voting/tx.proto` 中添加事件定義：
    ```protobuf
    message EventVoteCast {
      string voter_address = 1;
      string election_id = 2;
      string candidate_id = 3;
    }
    ```
    之後，重新生成 protobuf 程式碼：
    ```
    ignite generate proto-go
    ```
6.  **驗證與測試 `CastVote`**:
    * 重新編譯鏈：
        ```
        ignite chain build
        ```
    * 清除舊數據並重新初始化和啟動鏈，為 `alice` 分配 `votecredit`：
        ```bash
        rm -rf ~/.votesystem/
        votesystemd init mynode --chain-id voting-chain-dev
        votesystemd keys add alice --keyring-backend test
        votesystemd keys add bob --keyring-backend test
        ALICE_ADDR=$(votesystemd keys show alice -a --keyring-backend test)
        BOB_ADDR=$(votesystemd keys show bob -a --keyring-backend test)
        votesystemd add-genesis-account $ALICE_ADDR "1000000000stake,100votecredit"
        votesystemd add-genesis-account $BOB_ADDR "500000000stake" # Bob 初始沒有 votecredit
        votesystemd gentx alice 1000000stake --chain-id voting-chain-dev --from $ALICE_ADDR --keyring-backend test
        votesystemd collect-gentxs
        votesystemd validate-genesis
        votesystemd start
        ```
    * 在另一個終端中，執行以下操作：
        1.  **註冊 Alice**:
            ```bash
            votesystemd tx identity register-voter "alice_id_hash" --from $ALICE_ADDR --chain-id voting-chain-dev --fees 5stake --keyring-backend test -y
            ```
            等待交易確認。
        2.  **Alice 投票**:
            ```bash
            votesystemd tx voting cast-vote "candidate_X" "election_2024" --from $ALICE_ADDR --chain-id voting-chain-dev --fees 5stake --keyring-backend test -y
            ```
            交易成功。
        3.  **檢查 Alice 的 votecredit 餘額**: 應減少 1。
            ```bash
            votesystemd query bank balances $ALICE_ADDR
            ```
        4.  **Alice 嘗試再次為同一選舉投票**:
            ```bash
            votesystemd tx voting cast-vote "candidate_Y" "election_2024" --from $ALICE_ADDR --chain-id voting-chain-dev --fees 5stake --keyring-backend test -y
            ```
            交易失敗，提示 "already voted"。
        5.  **嘗試讓未註冊的 Bob 投票**:
            ```bash
            votesystemd tx voting cast-vote "candidate_X" "election_2024" --from $BOB_ADDR --chain-id voting-chain-dev --fees 5stake --keyring-backend test -y
            ```
            交易失敗，提示 "voter not registered"。
        6.  **註冊 Bob，但不給 VoteCoin，然後嘗試投票**:
            ```bash
            votesystemd tx identity register-voter "bob_id_hash" --from $BOB_ADDR --chain-id voting-chain-dev --fees 5stake --keyring-backend test -y
            ```
            等待交易確認。
            ```bash
            votesystemd tx voting cast-vote "candidate_X" "election_2024" --from $BOB_ADDR --chain-id voting-chain-dev --fees 5stake --keyring-backend test -y
            ```
            交易失敗，提示 "insufficient vote coin"。
        所有測試結果均符合預期。

#### B. 實現 `GetElectionResult` 查詢邏輯

1.  **修改 `x/voting/keeper/query_get_election_result.go`**:
    更新 `GetElectionResult` 函數的邏輯：
    ```go
    package keeper

    import (
        "context"

        "votesystem/x/voting/types"
        sdk "github.com/cosmos/cosmos-sdk/types"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
    )

    func (k Keeper) GetElectionResult(goCtx context.Context, req *types.QueryGetElectionResultRequest) (*types.QueryGetElectionResultResponse, error) {
        if req == nil {
            return nil, status.Error(codes.InvalidArgument, "invalid request")
        }
        if req.ElectionID == "" {
            return nil, status.Error(codes.InvalidArgument, "election ID cannot be empty")
        }

        ctx := sdk.UnwrapSDKContext(goCtx)

        allVoteRecords := k.GetAllVoteRecord(ctx)
        electionResults := make(map[string]uint64)

        for _, record := range allVoteRecords {
            if record.ElectionID == req.ElectionID {
                electionResults[record.CandidateID]++
            }
        }

        return &types.QueryGetElectionResultResponse{
            ElectionId: req.ElectionID, // Proto field name is election_id
            Results:    electionResults, // 直接使用 map
        }, nil
    }
    ```
2.  **定義查詢回應**: 
    在 `proto/votesystem/voting/query.proto` 中定義 `QueryGetElectionResultResponse`：
    ```protobuf
    message QueryGetElectionResultResponse {
      string election_id = 1;
      map<string, uint64> results = 2; // candidateID -> vote count
    }
    ```
    然後運行 
    ```
    ignite generate proto-go
    ```
3.  **驗證與測試 `GetElectionResult`**:
    * 重新編譯鏈：
        ```
        ignite chain build
        ```
    * 重啟鏈 (確保 Alice 之前的投票記錄存在)：
        ```
        votesystemd start
        ```
    * 在另一個終端中，執行查詢：
        ```bash
        votesystemd query voting get-election-result "election_2024"
        ```
        輸出應類似：
        ```json
        {
          "election_id": "election_2024",
          "results": {
            "candidate_X": "1"
          }
        }
        ```
        結果符合預期。


## 第 7 步：配置多節點網路

本步驟將說明如何設定一個由兩台在 VirtualBox 虛擬機上運行的 `votesystemd` 節點組成的多節點測試網路。

### 7.1 環境

* 使用 2 台 Ubuntu22.04 系統的 VM。
* 使用上一步上傳到github上的code
    ```bash
    git clone https://github.com/matthiola0/cosmos_votesystem
    cd cosmos_votesystem
    go mod tidy
    ignite chain build
    ```

### 7.2 VirtualBox 網路設定

#### 建立 NAT 網路：

1. 開啟 VirtualBox ->「檔案」->「工具」->「網路管理員」。
2. 點擊「建立」，為新的 NAT 網路命名（例如：`NatNetwork`）。
3. 網路 CIDR 可保留預設（如 10.0.2.0/24）。
4. 確保「啟用網路」已勾選。

#### 設定 VM 網路介面卡：

1. 關閉 VM。
2. 選擇 VM ->「設定」->「網路」。
3. 設定「附加到」為「NAT 網路」，名稱選 `NatNetwork`。

#### 驗證網路連線：

1. 啟動兩台 VM，使用 `ip a` 或 `ifconfig` 取得 IP。
2. VM1 上執行：`ping <VM2_IP>`，VM2 上執行：`ping <VM1_IP>`。

### 7.3 區塊鏈節點設定

#### 7.3.1 清除舊資料

在 VM1 與 VM2 上執行：

```bash
rm -rf ~/.votesystem
mkdir -p ~/.votesystem
```

#### 7.3.2 初始化節點

* VM1:

```bash
votesystemd init node1 --chain-id voting-chain-dev --home ~/.votesystem
```

* VM2:

```bash
votesystemd init node2 --chain-id voting-chain-dev --home ~/.votesystem
```

#### 7.3.3 建立驗證者帳戶

* VM1:

```bash
votesystemd keys add validator1 --keyring-backend test --home ~/.votesystem
```

* VM2:

```bash
votesystemd keys add validator2 --keyring-backend test --home ~/.votesystem
```

#### 7.3.4 加入創世帳戶

* VM1:

```bash
VALIDATOR1_ADDR=$(votesystemd keys show validator1 -a --keyring-backend test --home ~/.votesystem)
votesystemd add-genesis-account $VALIDATOR1_ADDR "1000000000stake,1000votecredit" --home ~/.votesystem
```

* VM2:

```bash
VALIDATOR2_ADDR=$(votesystemd keys show validator2 -a --keyring-backend test --home ~/.votesystem)
votesystemd add-genesis-account $VALIDATOR2_ADDR "100000stake,10votecredit" --home ~/.votesystem

echo $VALIDATOR2_ADDR
```

* VM1：使用上步從 VM2 複製的地址：

```bash
votesystemd add-genesis-account <VALIDATOR2_ADDR> "1000000000stake,1000votecredit" --home ~/.votesystem
```

#### 7.3.5 產生創世交易（Gentx）

* VM1:

```bash
NODE1_ID=$(votesystemd tendermint show-node-id --home ~/.votesystem)
votesystemd gentx validator1 1000000stake \
  --chain-id voting-chain-dev \
  --from validator1 \
  --keyring-backend test \
  --home ~/.votesystem \
  --ip <VM1_IP> \
  --node-id $NODE1_ID
```

* VM2:

```bash
NODE2_ID=$(votesystemd tendermint show-node-id --home ~/.votesystem)
votesystemd gentx validator2 1000000stake \
  --chain-id voting-chain-dev \
  --from validator2 \
  --keyring-backend test \
  --home ~/.votesystem \
  --ip <VM2_IP> \
  --node-id $NODE2_ID
```

#### 7.3.6 收集 Gentx 並分發 Genesis 檔案

* 將VM2的 ~/.votesystem/config/gentx/<gentx-*.json> 檔案貼到VM1的 ~/.votesystem/config/gentx/ 下
<!-- 
```bash
# 在 VM1:
scp user@<VM2_IP>:~/.votesystem/config/gentx/<gentx-*.json> ~/.votesystem/config/gentx/
``` -->

* VM1:

```bash
votesystemd collect-gentxs --home ~/.votesystem
votesystemd validate-genesis --home ~/.votesystem
```

* VM1 genesis.json -> VM2 genesis.json(複製貼上):
<!-- 
```bash
scp ~/.votesystem/config/genesis.json user@<VM2_IP>:~/.votesystem/config/
``` -->

#### 7.3.7 config.toml 配置

**查看 NODE_ID:**
```bash
votesystemd tendermint show-node-id --home ~/.votesystem/
```

**VM1** `~/.votesystem/config/config.toml`：

```toml
# TCP or UNIX socket address for the RPC server to listen on
laddr = "tcp://0.0.0.0:26657"
...
persistent_peers = "<NODE2_ID>@<VM2_IP>:26656"
...
addr_book_strict = false  // 設成 false
```

**VM2** `~/.votesystem/config/config.toml`：

```toml
# TCP or UNIX socket address for the RPC server to listen on
laddr = "tcp://0.0.0.0:26657"
...
persistent_peers = "<NODE1_ID>@<VM1_IP>:26656"
...
addr_book_strict = false  // 設成 false
```

### 7.4 啟動節點

* VM1:

```bash
votesystemd start --home ~/.votesystem
```

* VM2:

```bash
votesystemd start --home ~/.votesystem
```

### 7.5 驗證網路運作

* 查看日誌輸出是否有 `Added peer` 等資訊。
* 檢查同步區塊：

```bash
curl http://localhost:26657/status
```

* 確認 `result.sync_info.latest_block_height` 持續增加。
* 測試節點斷線與重新加入。

## 8. votesystem POA 共識機制實施 - 創世檔模板建置

### 8.1 POA 創世檔模板創建步驟

創建 POA 創世檔模板：

```bash
CHAIN_DIR_BASE=~/.votesystem_poa_setup
rm -rf $CHAIN_DIR_BASE
mkdir -p $CHAIN_DIR_BASE
votesystemd init mynode-poa-template --chain-id poa-chain-template --home $CHAIN_DIR_BASE
votesystemd keys add authoritytemplate --keyring-backend test --home $CHAIN_DIR_BASE
AUTHORITYTEMPLATE_ADDR=$(votesystemd keys show authoritytemplate -a --keyring-backend test --home $CHAIN_DIR_BASE)
votesystemd add-genesis-account $AUTHORITYTEMPLATE_ADDR 1000000000stake,1000000000votecredit --home $CHAIN_DIR_BASE
votesystemd gentx authoritytemplate 1000000stake --chain-id poa-chain-template --from $AUTHORITYTEMPLATE_ADDR --keyring-backend test --home $CHAIN_DIR_BASE
votesystemd collect-gentxs --home $CHAIN_DIR_BASE
```

修改 `$CHAIN_DIR_BASE/config/genesis.json` 文件，調整 staking 參數如下：

```json
"staking": {
  "params": {
    "unbonding_time": "1814400s",
    "max_validators": 1,
    "max_entries": 7,
    "historical_entries": 10000,
    "bond_denom": "stake",
    "min_commission_rate": "0.000000000000000000"
  }
}
```

驗證創世檔配置：

```bash
votesystemd validate-genesis --home $CHAIN_DIR_BASE
```


## 9. 獨立投票區域 (Zone A & Zone B) 建置與啟動

本階段創建了兩個獨立的投票區域：zoneA 和 zoneB。每個區域作為 votesystem 邏輯的一個獨立實例運行。

### 9.1 votesystem 項目代碼準備

```bash
git clone https://github.com/matthiola0/cosmos_votesystem
cd cosmos_votesystem
go mod tidy
ignite chain build
```

編譯完成後，生成 `votesystemd` 二進制執行檔。

### 9.2 Zone A (regionA) 設定

#### 9.2.1 VM1 - nodeA1 初始化與配置

```bash
ZONE_A_HOME=~/.zoneA
NODE_A1_NAME=nodeA1
ZONE_A_CHAIN_ID=regionA-chain-1
VALIDATOR_A1_KEY_NAME=validatorA1
```

初始化節點：

```bash
rm -rf $ZONE_A_HOME
votesystemd init $NODE_A1_NAME --chain-id $ZONE_A_CHAIN_ID --home $ZONE_A_HOME
```

應用 POA 創世檔配置，修改 `$ZONE_A_HOME/config/genesis.json`：

```json
"staking": {
  "params": {
    "unbonding_time": "1814400s",
    "max_validators": 1,
    "max_entries": 7,
    "historical_entries": 10000,
    "bond_denom": "stake",
    "min_commission_rate": "0.000000000000000000"
  }
}
```

創建驗證者金鑰並加入創世檔：

```bash
votesystemd keys add $VALIDATOR_A1_KEY_NAME --keyring-backend test --home $ZONE_A_HOME
VALIDATOR_A1_ADDR=$(votesystemd keys show $VALIDATOR_A1_KEY_NAME -a --keyring-backend test --home $ZONE_A_HOME)

votesystemd add-genesis-account $VALIDATOR_A1_ADDR 1000000000stake,1000votecredit --home $ZONE_A_HOME
votesystemd gentx $VALIDATOR_A1_KEY_NAME 1000000stake --chain-id $ZONE_A_CHAIN_ID --from $VALIDATOR_A1_ADDR --keyring-backend test --home $ZONE_A_HOME
votesystemd collect-gentxs --home $ZONE_A_HOME
votesystemd validate-genesis --home $ZONE_A_HOME
```

配置節點端口：

```toml
# config.toml
P2P.laddr = "tcp://0.0.0.0:26656"
RPC.laddr = "tcp://0.0.0.0:26657"

# app.toml
API.enable = true
API.address = "tcp://0.0.0.0:1317"
gRPC.address = "0.0.0.0:9090"
gRPC-Web.address = "0.0.0.0:9091"
```

#### 9.2.2 (可選) VM3 - nodeA2 初始化與配置

```bash
ZONE_A_NODE2_HOME=~/.zoneA_node2
NODE_A2_NAME=nodeA2
ZONE_A_CHAIN_ID=regionA-chain-1
VM1_IP=<VM1_ACTUAL_IP>

rm -rf $ZONE_A_NODE2_HOME
votesystemd init $NODE_A2_NAME --chain-id $ZONE_A_CHAIN_ID --home $ZONE_A_NODE2_HOME
scp your_user@$VM1_IP:$ZONE_A_HOME/config/genesis.json $ZONE_A_NODE2_HOME/config/
```

設定 persistent\_peers 為 `<nodeA1_ID>@<VM1_IP>:26656`。

### 9.3 Zone B (regionB) 設定

#### 9.3.1 VM2 - nodeB1 初始化與配置

```bash
ZONE_B_HOME=~/.zoneB
NODE_B1_NAME=nodeB1
ZONE_B_CHAIN_ID=regionB-chain-1
VALIDATOR_B1_KEY_NAME=validatorB1

rm -rf $ZONE_B_HOME
votesystemd init $NODE_B1_NAME --chain-id $ZONE_B_CHAIN_ID --home $ZONE_B_HOME
```

修改 `$ZONE_B_HOME/config/genesis.json`：

```json
"staking": {
  "params": {
    "unbonding_time": "1814400s",
    "max_validators": 1,
    "max_entries": 7,
    "historical_entries": 10000,
    "bond_denom": "stake",
    "min_commission_rate": "0.000000000000000000"
  }
}
```

創建驗證者金鑰並加入創世檔：

```bash
votesystemd keys add $VALIDATOR_B1_KEY_NAME --keyring-backend test --home $ZONE_B_HOME
VALIDATOR_B1_ADDR=$(votesystemd keys show $VALIDATOR_B1_KEY_NAME -a --keyring-backend test --home $ZONE_B_HOME)

votesystemd add-genesis-account $VALIDATOR_B1_ADDR 1000000000stake,1000votecredit --home $ZONE_B_HOME
votesystemd gentx $VALIDATOR_B1_KEY_NAME 1000000stake --chain-id $ZONE_B_CHAIN_ID --from $VALIDATOR_B1_ADDR --keyring-backend test --home $ZONE_B_HOME
votesystemd collect-gentxs --home $ZONE_B_HOME
votesystemd validate-genesis --home $ZONE_B_HOME
```

配置節點端口：

```toml
# config.toml
P2P.laddr = "tcp://0.0.0.0:36656"
RPC.laddr = "tcp://0.0.0.0:36657"

# app.toml
API.enable = true
API.address = "tcp://0.0.0.0:1318"
gRPC.address = "0.0.0.0:9092"
gRPC-Web.address = "0.0.0.0:9093"
```

#### 9.3.2 (可選) VM4 - nodeB2 初始化與配置

參照 9.2.2 節操作，使用 Zone B 的變數 (如 `ZONE_B_NODE2_HOME=~/.zoneB_node2`, `VM2_IP` 等)，設定 persistent\_peers 指向 nodeB1。

### 9.4 各 Zone 節點啟動與狀態觀測

啟動各節點：

```bash
# Zone A
votesystemd start --home $ZONE_A_HOME --log_level info
votesystemd start --home .zoneA_node2 --log_level info  # 若已配置

# Zone B
votesystemd start --home $ZONE_B_HOME --log_level info
votesystemd start --home .zoneB_node2 --log_level info  # 若已配置
```

觀察各節點的日誌輸出，確認節點已開始生成區塊並與其他對等節點建立連線。

## 10. 吞吐量 (TPS) 測試執行過程與結果分析 (針對 Zone A)

本節記錄使用 cometbft-load-test 工具對 Zone A 進行吞吐量測試的過程。

### 10.1 cometbft-load-test 安裝記錄

在 VM1 上安裝 cometbft-load-test。

```bash
# 檢查 Go 版本，cometbft-load-test v0.3.0 要求 Go 1.22+
go version # 若版本不足，需升級 Go

if ! command -v cometbft-load-test &> /dev/null; then
    echo "Installing cometbft-load-test..."
    git clone https://github.com/cometbft/cometbft-load-test.git
    cd cometbft-load-test
    # 可考慮 checkout 一個穩定版本，例如 v0.3.0
    # git checkout v0.3.0 
    go build -o ./build/cometbft-load-test ./cmd/cometbft-load-test/main.go
    sudo cp ./build/cometbft-load-test /usr/local/bin/
    cd ..
    # rm -rf cometbft-load-test # 清理源碼 (可選)
else
    echo "cometbft-load-test is already installed."
fi

# 查看幫助訊息以確認安裝
cometbft-load-test --help
```

### 10.2 針對 kvstore 的基礎負載測試記錄 (初步測試)

使用 cometbft-load-test 默認的 kvstore 客戶端工廠進行初步測試，以驗證測試工具本身及與鏈的基礎通信。

執行測試命令：

```bash
cometbft-load-test -c 10 -T 30 -r 1000 -s 250 \
  --endpoints "ws://localhost:26657/websocket" \
  --broadcast-tx-method async \
  --stats-output ./load_test_stats_kvstore.csv
```

參數記錄：

* `-c 10`: 並發連接數設定為 10
* `-T 30`: 總測試持續時間設定為 30 秒
* `-r 1000`: 每秒目標發送速率設定為 1000 tx/s
* `-s 250`: 交易大小設定為 250 bytes
* `--endpoints`: 目標節點 (nodeA1) 的 websocket 端點為 `ws://localhost:26657/websocket`
* `--broadcast-tx-method async`: 交易廣播模式設定為異步
* `--stats-output`: 聚合統計數據輸出至 `./load_test_stats_kvstore.csv`

觀測實時輸出，測試結束後檢查 `load_test_stats_kvstore.csv` 文件中的結果。

### 10.3 votesystem 自定義交易生成器 (Client) 實現記錄

為測試 votesystem 應用中的 castVote 交易，創建了自定義的客戶端 (Client) 和客戶端工廠 (ClientFactory)。

#### 步驟記錄

```bash
# 項目初始化
sudo mkdir -p /my-votesystem-load-tester/
sudo chown -R $(whoami):$(whoami) /my-votesystem-load-tester
cd /my-votesystem-load-tester
go mod init my-votesystem-load-tester

mkdir -p pkg/votesystemclient
mkdir -p cmd/my-votesystem-load-tester
```

#### 交易生成器代碼 (./pkg/votesystemclient/client.go)

實現了 loadtest.ClientFactory 和 loadtest.Client 接口，GenerateTx() 方法用於生成模擬的 castVote 交易負載。

```go
package votesystemclient

import (
    "fmt"
    "math/rand"
    "time"
    "github.com/cometbft/cometbft-load-test/pkg/loadtest"
)

type VoteSystemClientFactory struct{}

var _ loadtest.ClientFactory = (*VoteSystemClientFactory)(nil)

func (f *VoteSystemClientFactory) ValidateConfig(cfg loadtest.Config) error {
    if cfg.Size < 50 {
        // return fmt.Errorf("transaction size %d is too small", cfg.Size)
    }
    return nil
}

func (f *VoteSystemClientFactory) NewClient(cfg loadtest.Config) (loadtest.Client, error) {
    r := rand.New(rand.NewSource(time.Now().UnixNano()))
    return &VoteSystemClient{
        rng: r,
        electionID: "default-election",
    }, nil
}

type VoteSystemClient struct {
    rng        *rand.Rand
    electionID string
}

var _ loadtest.Client = (*VoteSystemClient)(nil)

func (c *VoteSystemClient) GenerateTx() ([]byte, error) {
    electionID := c.electionID
    voteOptionID := uint64(c.rng.Intn(3))
    voterSuffix := c.rng.Intn(10000)
    txPayload := fmt.Sprintf("voter=testVoter%d,election=%s,option=%d,padding=%s",
        voterSuffix,
        electionID,
        voteOptionID,
        randStr(150),
    )
    return []byte(txPayload), nil
}

const strChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
func randStr(length int) string {
    chars := make([]byte, length)
    seededRand := rand.New(rand.NewSource(time.Now().UnixNano()))
    for i := range chars {
        chars[i] = strChars[seededRand.Intn(len(strChars))]
    }
    return string(chars)
}

```

#### CLI 入口點代碼 (./cmd/my-votesystem-load-tester/main.go)

```go
package main

import (
    "log"
    "github.com/cometbft/cometbft-load-test/pkg/loadtest"
    "my-votesystem-load-tester/pkg/votesystemclient"
)

func main() {
    if err := loadtest.RegisterClientFactory("votesystem", &votesystemclient.VoteSystemClientFactory{}); err != nil {
        log.Fatalf("Failed to register client factory: %v", err)
    }
    loadtest.Run(&loadtest.CLIConfig{
        AppName:              "my-votesystem-load-tester",
        AppShortDesc:         "Load testing application for VoteSystem",
        AppLongDesc:          "Generates castVote transactions for the votesystem application.",
        DefaultClientFactory: "votesystem",
    })
}

```

#### 編譯過程

```bash
cd /my-votesystem-load-tester
go mod tidy
go build -o ./build/my-votesystem-load-tester ./cmd/my-votesystem-load-tester/main.go
```

編譯成功後，在 `./build/` 目錄下生成 `my-votesystem-load-tester` 可執行文件。

#### 執行自定義負載測試

```bash
/my-votesystem-load-tester/build/my-votesystem-load-tester \
    --client-factory votesystem \
    -c 10 -T 30 -r 1000 -s 213 \
    --endpoints "ws://localhost:26657/websocket" \
    --broadcast-tx-method async \
    --stats-output ./votesystem_load_test_s213_stats.csv
```

第二次測試，增加並發和速率：

```bash
/my-votesystem-load-tester/build/my-votesystem-load-tester \
    --client-factory votesystem \
    -c 20 \
    -T 30 \
    -r 2000 \
    -s 213 \
    --endpoints "ws://localhost:26657/websocket" \
    --broadcast-tx-method async \
    --stats-output ./votesystem_test_c20_r2k_s213_stats.csv
```
`-c 20` 表示將有 20 個node同時連接持續發送交易
`-T 30` 表示測試將持續運行 30 秒，然後自動停止
`-r 2000` 表示嘗試達到 TPS 2000
`-s 213` 表示工具生成的每筆交易數據大小都是 213 字節

結果：
```csvpreview
Parameter,Value,Units
total_time,37.048,seconds
total_txs,372296,count
total_bytes,79306240,bytes
avg_tx_rate,10048.956424,transactions per second
avg_data_rate,2140621.843681,bytes per second

```

TPS：10048





